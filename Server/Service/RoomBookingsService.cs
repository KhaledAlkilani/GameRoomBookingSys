
using gameroombookingsys.DTOs;
using gameroombookingsys.Enums;
using gameroombookingsys.Interfaces;
using gameroombookingsys.IRepository;
using Gameroombookingsys.Models;

namespace gameroombookingsys.Service
{
    public class RoomBookingsService : IRoomBookingsService
    {
        private readonly IRoomBookingsRepository _repository;
        private readonly ILogger<RoomBookingsService> _logger;
        public RoomBookingsService(IRoomBookingsRepository repository, ILogger<RoomBookingsService> logger)
        {
            _repository = repository;
            _logger = logger;
        }
        public async Task<RoomBookingDto> BookGameRoom(RoomBookingDto dto)
        {
            try
            {
                // Validate the incoming DTO.
                if (dto.BookingDateTime == default)
                    throw new ArgumentException("Booking date/time is required.");
                if (dto.Duration <= TimeSpan.Zero)
                    throw new ArgumentException("Duration must be greater than zero.");

                // Validate the playing alone and fellows properties.
                if (dto.isPlayingAlone && dto.Fellows > 0)
                    throw new ArgumentException("You cannot play alone and have fellows at the same time.");

                // Check room availability using the repository.
                bool isAvailable = await _repository.IsRoomAvailable(dto.BookingDateTime, dto.Duration);
                if (!isAvailable)
                    throw new InvalidOperationException("Room is not available at the requested time.");

                // Check if booking date/time is in the future.
                if (dto.BookingDateTime <= DateTime.Now)
                    throw new ArgumentException("Booking date/time must be in the future.");

                // Update status in DTO.
                dto.Status = gameroombookingsys.Enums.BookingStatus.Upcoming;

                // Map DTO to entity.
                var entity = new RoomBooking
                {
                    BookingDateTime = dto.BookingDateTime,
                    Duration = dto.Duration,
                    isPlayingAlone = dto.isPlayingAlone,
                    Fellows = dto.Fellows,
                    Status = dto.Status,
                };

                // Save the booking through the repository.
                var savedEntity = await _repository.AddRoomBooking(entity);

                // Optionally, map the saved entity back to a DTO.
                dto.Id = savedEntity.Id;  // Assuming your entity has an Id generated by the database.
                return dto;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error occurred in BookGameRoom in service.");
                throw;
            }
        }
        public async Task<RoomBookingDto> UpdateRoomBooking(int id, RoomBookingDto dto)
        {
            try
            {
                // Use the id from the URL as the definitive identifier.
                dto.Id = id;

                // Retrieve the existing booking by id.
                var booking = await _repository.GetRoomBookingById(id);
                if (booking == null)
                    throw new KeyNotFoundException("Booking not found.");

                // Check if the booking is already cancelled.
                if (booking.Status == gameroombookingsys.Enums.BookingStatus.Cancelled)
                    throw new InvalidOperationException("Booking is already cancelled and cannot be updated.");

                // If the update is intended to cancel the booking,
                // the client can simply set the status to Cancelled.
                if (dto.Status == gameroombookingsys.Enums.BookingStatus.Cancelled)
                {
                    // Prevent cancellation if the booking is in the past.
                    if (booking.BookingDateTime < DateTime.Now)
                        throw new InvalidOperationException("Cannot cancel a booking in the past.");

                    booking.Status = gameroombookingsys.Enums.BookingStatus.Cancelled;
                }
                else
                {
                    // Update the booking fields
                    booking.BookingDateTime = dto.BookingDateTime;
                    booking.Duration = dto.Duration;
                    booking.Devices = dto.Devices;
                    booking.isPlayingAlone = dto.isPlayingAlone;
                    booking.Fellows = dto.Fellows;
                    booking.Status = dto.Status;
                }

                // Save the updated booking through the repository.
                var updatedBooking = await _repository.UpdateRoomBooking(booking);

                // Map the updated entity back to a DTO.
                var updatedDto = new RoomBookingDto
                {
                    Id = updatedBooking.Id,
                    BookingDateTime = updatedBooking.BookingDateTime,
                    Duration = updatedBooking.Duration,
                    Devices = updatedBooking.Devices,
                    isPlayingAlone = updatedBooking.isPlayingAlone,
                    Fellows = updatedBooking.Fellows,
                    Status = updatedBooking.Status
                };

                return updatedDto;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error updating room booking.");
                throw;
            }
        }


        public Task<List<RoomBookingDto>> GetAllBookings()
        {
            throw new NotImplementedException();
        }

        public Task<List<RoomBookingDto>> GetHistoryBookings()
        {
            throw new NotImplementedException();
        }

        public Task<List<RoomBookingDto>> GetOngoingBookings()
        {
            throw new NotImplementedException();
        }

        public Task<RoomBookingDto> GetRoomBookingByPlayerId(int playerId)
        {
            throw new NotImplementedException();
        }

        public Task<List<RoomBookingDto>> GetUpcomingBookings()
        {
            throw new NotImplementedException();
        } 
    }
}
